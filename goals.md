## Global goals
* Пофиксить/обойти, что изменение внутреннего состояния парсера между леворекурсивными вызовами приводит к бесконечной рекурсии
	* Кажется, обойти это невозможно. Как вариант можно заставить пользователя хранить в состоянии только те величины, которые имеют конечное число значений при леворекурсивных вызовах. Например, тогда нельзя будет хранить в State глубину дерева разбора. Надо заметить, что здесь проблема даже не в монадичности.
* Пофиксить/обойти, что одинаковые парсеры с одинаковыми типовыми параметрами вызываются много раз
	* Кажется, что разные таблицы мемоизации в одинаково параметризованном парсере могут привести лишь к значительному уменьшению производительности, но не к некорректной работе парсера. Главное, чтобы все нетерминалы, вызывающиеся леворекурсивно (непосредственно или не непосредственно), были мемоизированы. Так будет обеспечена корректность работы парсера. При соблюдении этого требования, но в отсутствии дополнительной мемоизации парсер должен работать корректно, однако со скоростью обычного монадического комбинатора парсеров.
* Описать формальную семантику и синтаксис CPS комбинаторов
* Понять, почему парсер на Lama работает медленно
	* Скорее всего дело в выделении памяти или в работе стандартных коллекций (Выявлено, что время работы сильно зависит от возвращаемых значений парсера, то есть от того, что находится в rs. Если в rs просто строки,то парсер работает быстро, если там S expressions, то значительно медленнее, если там замыкания - примерно в 2 раза медленнее, чем с S expressions)
* Доказать, что в ks не может оказаться одинаковых продолжений или что одинаковые продолжения в ks ни на что не влияют 
	* Нельзя хранить продолжения в set, потому что есть валидные ситуации, при которых в ks должны лежать структурано одинаковые продолжения, которые соответсвтуют разным вариантам разбора. Например, рассмотрим следующую грамматику на вводе "ab":
		```
		S -> A "b"
		  -> A "b"

		A -> "a"
		```
	Должно получиться два результата с одинаковыми деревьями разбора. Если же в ks хранить только разные продолженя, то результат будет один, потому что два продолжения "b" и "b" будут учтены лишь единожды. Разумеется этот пример предполагает, что парсер разбирает неоднозначную грамматику.
	* Пример, при котором ks не может быть set также показывает, что нам нужно запретить, чтобы в ks лежали только одинаковые "по ссылке" продолжения (то есть продолжения из одной и той же ветки одного и того же правила), а не просто струкрутрно одинаковые продолжения (то есть равные как бы по equals). Рассмотрим ситуацию, когда в продолжении некоторого парсера могут лежать одинаковые (в смысле "по ссылке") продолжения. Заметим, что для добавления продолжения парсера в одно и то же множество ks этот парсер должен быть вызван из одного и того же state. 

	Пусть существует "проблемный" мемоизированный парсер A, в списке продолжений которого лежат два одинаковых продолжения. Если это так, значит данный парсер был вызван два раза из одной и той же альтернативы какого-то другого парсера, назовём этот родительский парсер P. Чтобы A был вызван с одним и тем же продолжением дважды, необходимо, чтобы P был вызван дважды с одним тем же state. К вызову P может привести вызов какого-то другого парсера (1), либо вызов P (2). Рассмотрим 2. Если к вызовы P привёл P, значит, P рекурсивный. При этом принимая во внимания факт, что между вызовами state не должен 

## 13.01.2024
