## Global goals
* Пофиксить/обойти, что изменение внутреннего состояния парсера между леворекурсивными вызовами приводит к бесконечной рекурсии
	* Кажется, обойти это невозможно. Как вариант можно заставить пользователя хранить в состоянии только те величины, которые имеют конечное число значений при леворекурсивных вызовах. Например, тогда нельзя будет хранить в State глубину дерева разбора. Надо заметить, что здесь проблема даже не в монадичности.
* Пофиксить/обойти, что одинаковые парсеры с одинаковыми типовыми параметрами вызываются много раз
	* Кажется, что разные таблицы мемоизации в одинаково параметризованном парсере могут привести лишь к значительному уменьшению производительности, но не к некорректной работе парсера. Главное, чтобы все нетерминалы, вызывающиеся леворекурсивно (непосредственно или не непосредственно), были мемоизированы. Так будет обеспечена корректность работы парсера. При соблюдении этого требования, но в отсутствии дополнительной мемоизации парсер должен работать корректно, однако со скоростью обычного монадического комбинатора парсеров.
* Описать формальную семантику и синтаксис CPS комбинаторов
* Понять, почему парсер на Lama работает медленно
	* Скорее всего дело в выделении памяти или в работе стандартных коллекций (Выявлено, что время работы сильно зависит от возвращаемых значений парсера, то есть от того, что находится в rs. Если в rs просто строки,то парсер работает быстро, если там S expressions, то значительно медленнее, если там замыкания - примерно в 2 раза медленнее, чем с S expressions)
* Доказать, что в ks не может оказаться одинаковых продолжений или что одинаковые продолжения в ks ни на что не влияют 
	* Нельзя хранить продолжения в set, потому что есть валидные ситуации, при которых в ks должны лежать структурано одинаковые продолжения, которые соответсвтуют разным вариантам разбора. Например, рассмотрим следующую грамматику на вводе "ab":
		```
		S -> A "b"
		  -> A "b"

		A -> "a"
		```
	Должно получиться два результата с одинаковыми деревьями разбора. Если же в ks хранить только разные продолженя, то результат будет один, потому что два продолжения "b" и "b" будут учтены лишь единожды. Разумеется этот пример предполагает, что парсер разбирает неоднозначную грамматику.
	* Пример, при котором ks не может быть set также показывает, что нам нужно запретить, чтобы в ks лежали только одинаковые "по ссылке" продолжения (то есть продолжения из одной и той же ветки одного и того же правила), а не просто струкрутрно одинаковые продолжения (то есть равные как бы по equals). Рассмотрим ситуацию, когда в продолжении некоторого парсера могут лежать одинаковые (в смысле "по ссылке") продолжения. Заметим, что для добавления продолжения парсера в одно и то же множество ks этот парсер должен быть вызван из одного и того же state. 

	Пусть существует "проблемный" мемоизированный парсер A, в списке продолжений которого лежат два одинаковых продолжения. Если это так, значит данный парсер был вызван два раза из одной и той же альтернативы какого-то другого парсера, назовём этот родительский парсер P. Чтобы A был вызван с одним и тем же продолжением дважды, необходимо, чтобы P был вызван дважды с одним тем же state. К вызову P может привести вызов какого-то другого парсера (1), либо вызов P (2). Рассмотрим 2. Если к вызовы P привёл P, значит, P рекурсивный. При этом принимая во внимания факт, что между вызовами state не должен 

## 13.01.2024

## 06.02.2024
Подходы для устранения незавершения dpc:

1. Отслеживать максимумальное число поглощённых символов среди альтернатив нетерминала. Если число не увеличивается, то надо возвращать пустой список в качестве результата разбора нетермирала.  
**Не работает** 
```
	C -> [C]c
	  -> a
```
На такой грамматике строчка acс не будет принята, потому что максимальное число поглощённых символов в альтернативе всегда будет 1 (будет поглощаться символ a).

1. Отслеживать ситуацию, когда в результате раскрытия def1 возвращается def2. Если в def2 первый парсер seq совпадает с первым парсеров seq в def1, поток ввода не изменился и при этом других результатов у def1 нет, то надо возвращать пустой список в результате раскрытия def1.  
**Не работает для опосредованной левой рекурсии**
```
	A -> [B]
	B -> [C]
	C -> [A]
```
На такой грамматике при любом вводе первый парсер в def1 не будет совпадать с первым парсером в def2.

1. Отслеживать раскрытие def. Пока при раскрытии def есть хотя бы один результат, в котором поглотился символ, нужно продолжать раскрывать. Если же в результате раскрытия def вернулись только такие результаты, в которых не изменился поток ввода, то в качестве результата def нужно вернуть пустой список.  
**Не работает** 
```
	A -> [B]
	B -> b
```
Не примет строчку b, потому что при раскрытии A вернётся def без поглощения символов.

1. Отслеживать максимальное число поглощённых символов при раскрытии def. При раскрытии def мы получаем множество результатов с недоразобранными остатками ввода. Найдём крайтчайший недоразобранный остаток ввода. Длина этого остатка характеризует максимальное число поглощённых символов при разборе def. Передадим эту длину при вызове всех def1 получившихся в результате разбора def. Все def1 также посчитают максимальное число поглощённых символов. Если для некоторого def1 число это будет меньше, чем у родительского def, то возвращаем пустой список в качестве результата этого def1.  
**Не работает**  
Например для для опосредованной левой рекурсии  
```
	A -> [B]
	B -> [C]
	C -> [A]
```

## 08.02.2024
В сущности подход dpc есть наивный рекурсивный спуск (без мемоизации, без предсказания следующего нетерминала (как в LL1, LL2, ...)), но с возможностью удобно анализировать состояние разбора. *Задача сейчас сводится к тому, чтобы в этом состоянии определить зацикливание в левой рекурсии и разрешить его.*  
(Пока будем считать, что состояние разбора есть последовательность символов, которая может лишь уменьшаться)  

Чтобы решить задачу нужно уметь определять две вещи:

1. Что при разборе нетерминала происходит леворекурсивный вызов
	* В нашем случае определим леворекурсивный вызов так:  
	Если при разборе (1) некоторого нетерминала A возникла необходимость разобрать этот же нетерминал A и при этом после начала разбора (1) не было поглощено символов потока ввода (не изменилось состояние разбора), назовём эту необходимость левой рекурсией. Или `A =>+ A$\alpha$`
	**Гипотетические методы определения левой рекурсии:**
		1. Для каждого def будем хранить множество нетерминалов, которые являются его родительсвким нетерминалами разного уровня. Такие нетерминалы представляют собой функции, будем хранить ссылки на эти функции. К каждой функции припишем состояние разбора, на котором эта функция была вызвана (само это состояние не должно учитываться при поиске по множеству). Теперь делая вызов любого def, будем проверять, есть ли первый парсер из его seq в множестве родителей для этого def. Если родитель найден (если родителей несколько, то берём того, что добавлен в множество последним), то проверяем состояние разбора текущего def с тем, на котором был вызван родитель. Если состояние совпало, то это левая рекурсия. (Если родителей было несколько, то при несовпадении состояний, необъодимо проверить всех родителей.)
		1. Предположим, что мы раскрываем некоторый def из общего списка результатов. У нас получается список результатов, пройдёмся по отсроченным результатам (назовём каждый из них def1) из него и отфильтруем def1 такие, что первый парсер def1 и первый парсер def равны (это будет сравнение функций по ссылке (будем считать, что мы храним seq как список парсеров (то есть функций))). Среди убранных из списка def1 переложим те def1, состояние которых не равно состоянию, на котором был вызван def, в список неотложенных результатов. Оставшиеся убранные def1 яляются отложенными леворекурсивными парсерами. С оставшимися отсроченными парсерами из результатов def повторим действия по раскрытию аналогичные тем, что мы провели с def. Рано или поздно список отложенных результатов после фильтрации должен опустеть. Останется список неотложенных результатов(этот список в том числе будет содержать отложенные леворекурсивные парсеры с изменившемся состоянием) и список леворекурсивных отложенных результатов. Если список не отложенных результатов пуст, то фейлим def. Если список результатов не пуст, положим оба полученных списка в общий список результатов (чтобы тот был разобран далее).  
		*В целом идея данного подхода заключается в том, что мы вычисляем все ветки разбора либо до состояния левой рекурсии, либо до состояния, когда был поглощён символ входного потока. Если говорить в терминах Д.Ю., то мы ищем, в какой момент считать максимум поглощённых символов.*
			* Это не работает в случае, когда `С =>+ C`, то есть когда нетерминал превращается в сам себя. Чтобы это преодолеть, можно в итоговом списке отложенных леворекурсивных результатов проверить, что сущетсвуют результаты с длиной seq больше 1.  
			* Изменим структуру Deferred. Пусть Deferred вместе с отсроченным парсером также хранит парсер, который привёл к отсрочке. Именно этот парсер надо сравнивать при фильтрации списка.
			* Данный алгоритм можно несколько изменить. Для этого вместо перекладывания def1, у которых поменялось состояние, в список неотложенных результатов будем перекладывать эти def1 обратно в список отложенных результатов, который мы фильтровали. Тогда мы раскроем их на следующей итерации алгоритма. А в итоговом результате алгоритма в списке неотложенных результатов действительно будут только неотложенные результаты. Итоговый алгоритм получится следующим.  
			**Алгоритм раскрытия deferred результата:**

				1. Назовём раскрываемый результат def. Запустим отсроченный парсер внутри def. В результате получится список результатов, назовём его defRes.
				1. Разделим элементы defRes на два списка. В первый список, называемый defRes1, положим элементы defRes, которые:
					1. Являются отсроченными
					1. Имеют своим первым парсером парсер, равный def (в предполагаемый реализации это значит, что в списке seq рассматриваемого элемента defRes первый элемент должен быть равен def)
					1. Имеют state, равный состоянию результата def  

					Во второй список, называемый defRes2, положим все остальные элементы списка defRes.
				1. Для каждого отсроченного парсера из defRes2
					1. Применить алгоритм раскрытия deferred результата
				1. Результаты применения алгоритма для каждого отсроченного элемента defRes2 сконкатенировать в список, названный defResImm
				1. Добавить в defResImm неотложенные парсеры из defRes2
				1. Если defRes1 не пуст и defResImm пуст, вернуть пустой список
				1. Иначе вернуть defRes1 + defRes2

```
A -> Ca
  -> a
C -> Ac
  -> Cd
```
"eee"

```
def // раскрываемые результат

defRes = def.parser(def.state)
defRes1, defRes2 = [], []
for res in defRes:
	if res is Deferred && res.parser.first() == def.parser && res.state == def.state:
		defRes1 += res
	else:
		defRes2 += res

```

1. Что этот леворекурсивный вызов обречён на провал


Как избавляться от опосредованной левой рекурсии путём перестраивания грамматики: https://neerc.ifmo.ru/wiki/index.php?title=Устранение_левой_рекурсии

Опишем, что должен вернуть вызванный deferred парсер с помощью инвариантов:  
Пусть есть стэк разбора, который хранит информацию о том, в рамках каких нетерминалов идёт разбор и с какими состояниями. 

1. Парсер должен вернуть список результатов, таких что:
	1. Результат неотложенный
	1. Или первый парсер отложенного результата присутствует в стэке разбора с состоянием равному тому, что в стэке.

```

T -> T + T
  -> T - T
  -> t
```
t+t

1. Кажется, что подход Дмитрия Юрьевича неверный, потому что парсер при развёртывании в левую рекурсию может некоторое время не поглощать элементы, а потом начать это делать. 
	1. Пример:
		```
		A -> Ca
		  -> a
		C -> Ac
		  -> Cd
		```
		C - стартовый нетерминал
		"acacddd"

	1. Вот упрощённый пример
		```
		C -> Сc
		  -> Cd
		  -> e
		```
		"ecccddd"

		Здесь нужная ветка анализа будет несколько итераций левой рекурсии поглощать лишь 1 символ "e", а потом фейлится, но потом (когда на конце накопится 3 "d") парсер начнёт поглощать всё больше элементов и в итоге примет всю строку ввода.

	1. При этом есть случае, когда количество поглощённых символов не увеличивается и увеличиваться не будет. Например:
		```
			C -> [C]c
			  -> a
		```
		"aaa"

		Здесь всегда будет поглощаться один символ, но, сколько бы итераций левой рекурсии не произошло, больше символов не поглотится.

		```
			C -> aC'
			C'-> cC'
			C'-> eps 
		```

## 23.02.2024
**По итога встречи:**  
Изучить две статьи с новым подходом. Одна ostap, другая статья Фроста. Ждать ответ на отосланный ДЮ контрпример. Сделать всё как можно быстрее, по итогам связаться. Реализация нового подхода есть в Lama.

Подход из статьи Parser Combinators for Ambiguous Left-Recursive Grammars связан с отрубанием леворекурсивных веток длины, которая превышает длину остатка ввода.

Библиотека в haskell с парсерами в CPS стиле https://hackage.haskell.org/package/Agda-2.6.3/docs/Agda-Utils-Parser-MemoisedCPS.html.


## 29.02.2024
**По итога встречи:**
Изучить:

1. Алгоритм Кока янгера косами
1. Алгоритм Эрли

*Проверить:*
Если грамматика LL(k), то будет работать метод Булычев

*Попробовать:*
В случае сбоя переходить на более тяжёлый способ разбора (CPS)

*Мотивация:*
Большая часть грамматик LL(k)

Почитать про Selectable парсер комбинаторы.

Комплексный подход, объединяющий комбинатор inner и deferred. Можно использовать комбинатор, когда мы в deferred нашли левую рекурсию.



```
(((((73+x1!=(99!=x1))<=((166!!967)!!27&&x2))+((x2-x3>x0*276)>((x0>=192)==(x0>=876))))-((x3>675!!x0<772)-((x2==444)>=(715<x1))<((x2<=209)<=(570==905)&&x0*x3==(x2!=x3)))!=((((507!!x2)&&720>x3)*((x3<x3)*(x0>=x2))!!(987*159&&x0>=300)>((628!!x1)!!x3*574))&&((383!=x0)+(923<231)==(x1+x1)*(x2*548))<(x2*744!=x0-x0)+((x1>=x1)<=(x2<=657))))!=(((x1&&197!!948<x0)+((x3!=172)<(x3==310))!=((x1*x3!!817==x1)>(x0-x1<=(32!=x0))))==((773!=x0&&507>944!!(x0!=x2)==(255&&228))>((x2>=x0)==(x2!!904))+((x2>x2)!=(x1<=x0))))-((((x3!=364)<=(x2<=x3)!!(972>x1)!=(754!!x3))+((x1>x1)+x3*x0)*((x2&&x2)-(x1<x0)))+(((900>=x3)-(x1&&955)>=(x0!=x0)+(x1!!x2))!=(((789==x1)>926-553)!=((484>x2)<744*x2))))!!((((x2>=315)*(x3&&x0)==(549<307)*(x1<=421)&&(x1-733==x0-142)<(65!=324)+(x2==x0))>((((0!=x3)>=(x2!!x1))>=x1*529+(x0>=382))!=((293+64==x2-((((((73+x1!=(99!=x1))<=((166!!967)!!27&&x2))+((x2-x3>x0*276)>((x0>=192)==(x0>=876))))-((x3>675!!x0<772)-((x2==444)>=(715<x1))<((x2<=209)<=(570==905)&&x0*x3==(x2!=x3)))!=((((507!!x2)&&720>x3)*((x3<x3)*(x0>=x2))!!(987*159&&x0>=300)>((628!!x1)!!x3*574))&&((383!=x0)+(923<231)==(x1+x1)*(x2*548))<(x2*744!=x0-x0)+((x1>=x1)<=(x2<=657))))!=(((x1&&197!!948<x0)+((x3!=172)<(x3==310))!=((x1*x3!!817==x1)>(x0-x1<=(32!=x0))))==((773!=x0&&507>944!!(x0!=x2)==(255&&228))>((x2>=x0)==(x2!!904))+((x2>x2)!=(x1<=x0))))-((((x3!=364)<=(x2<=x3)!!(972>x1)!=(754!!x3))+((x1>x1)+x3*x0)*((x2&&x2)-(x1<x0)))+(((900>=x3)-(x1&&955)>=(x0!=x0)+(x1!!x2))!=(((789==x1)>926-553)!=((484>x2)<744*x2))))!!((((x2>=315)*(x3&&x0)==(549<307)*(x1<=421)&&(x1-733==x0-142)<(65!=324)+(x2==x0))>((((0!=x3)>=(x2!!x1))>=x1*529+(x0>=382))!=((293+64==x2-189)>((37<x3)!=(x2!=x3)))))!=(((736+x3&&x0==x1!!(x1&&x3)+(193+74))>((x2&&505)>(523==725)&&(317==x2!!412-229)))>=(((x1&&899)>(497==323)&&((522!!x0)!!696-80))==(x0-941!=(529!=498)!!(x3<55)+(207!=x3))))!!(((626>x1)+(469>=787)<=((x2&&529)!=(666!=x0))&&(43*5==(x0!!655))!=(x3-593<=951-x3))<=((((x2>x3)==(875>=x0))<(x0&&360)*(590!!x0))>=(((x3>x0)>=880*425)<=((x0<x1)==(x0<222)))))>(((964&&215)-(138!!202)>=((370<x2)<=(x1>=x2)))>=((x0<748)-(242!=x1))-((704-880)-(855&&160))!!(((((((((73+x1!=(99!=x1))<=((166!!967)!!27&&x2))+((x2-x3>x0*276)>((x0>=192)==(x0>=876))))-((x3>675!!x0<772)-((x2==444)>=(715<x1))<((x2<=209)<=(570==905)&&x0*x3==(x2!=x3)))!=((((507!!x2)&&720>x3)*((x3<x3)*(x0>=x2))!!(987*159&&x0>=300)>((628!!x1)!!x3*574))&&((383!=x0)+(923<231)==(x1+x1)*(x2*548))<(x2*744!=x0-x0)+((x1>=x1)<=(x2<=657))))!=(((x1&&197!!948<x0)+((x3!=172)<(x3==310))!=((x1*x3!!817==x1)>(x0-x1<=(32!=x0))))==((773!=x0&&507>944!!(x0!=x2)==(255&&228))>((x2>=x0)==(x2!!904))+((x2>x2)!=(x1<=x0))))-((((x3!=364)<=(x2<=x3)!!(972>x1)!=(754!!x3))+((x1>x1)+x3*x0)*((x2&&x2)-(x1<x0)))+(((900>=x3)-(x1&&955)>=(x0!=x0)+(x1!!x2))!=(((789==x1)>926-553)!=((484>x2)<744*x2))))!!((((x2>=315)*(x3&&x0)==(549<307)*(x1<=421)&&(x1-733==x0-142)<(65!=324)+(x2==x0))>((((0!=x3)>=(x2!!x1))>=x1*529+(x0>=382))!=((293+64==x2-189)>((37<x3)!=(x2!=x3)))))!=(((736+x3&&x0==x1!!(x1&&x3)+(193+74))>((x2&&505)>(523==725)&&(317==x2!!412-229)))>=(((x1&&899)>(497==323)&&((522!!x0)!!696-80))==(x0-941!=(529!=498)!!(x3<55)+(207!=x3))))!!(((626>x1)+(469>=787)<=((x2&&529)!=(666!=x0))&&(43*5==(x0!!655))!=(x3-593<=951-x3))<=((((x2>x3)==(875>=x0))<(x0&&360)*(590!!x0))>=(((x3>x0)>=880*425)<=((x0<x1)==(x0<222)))))>(((964&&215)-(138!!202)>=((((((((73+x1!=(99!=x1))<=((166!!967)!!27&&x2))+((x2-x3>x0*276)>((x0>=192)==(x0>=876))))-((x3>675!!x0<772)-((x2==444)>=(715<x1))<((x2<=209)<=(570==905)&&x0*x3==(x2!=x3)))!=((((507!!x2)&&720>x3)*((x3<x3)*(x0>=x2))!!(987*159&&x0>=300)>((628!!x1)!!x3*574))&&((383!=x0)+(923<231)==(x1+x1)*(x2*548))<(x2*744!=x0-x0)+((x1>=x1)<=(x2<=657))))!=(((x1&&197!!948<x0)+((x3!=172)<(x3==310))!=((x1*x3!!817==x1)>(x0-x1<=(32!=x0))))==((773!=x0&&507>944!!(x0!=x2)==(255&&228))>((x2>=x0)==(x2!!904))+((x2>x2)!=(x1<=x0))))-((((x3!=364)<=(x2<=x3)!!(972>x1)!=(754!!x3))+((x1>x1)+x3*x0)*((x2&&x2)-(x1<x0)))+(((900>=x3)-(x1&&955)>=(x0!=x0)+(x1!!x2))!=(((789==x1)>926-553)!=((484>x2)<744*x2))))!!((((x2>=315)*(x3&&x0)==(549<307)*(x1<=421)&&(x1-733==x0-142)<(65!=324)+(x2==x0))>((((0!=x3)>=(x2!!x1))>=x1*529+(x0>=382))!=((293+64==x2-189)>((37<x3)!=(x2!=x3)))))!=(((736+x3&&x0==x1!!(x1&&x3)+(193+74))>((x2&&505)>(523==725)&&(317==x2!!412-229)))>=(((x1&&899)>(497==323)&&((522!!x0)!!696-80))==(x0-941!=(529!=498)!!(x3<55)+(207!=x3))))!!(((626>x1)+(469>=787)<=((x2&&529)!=(666!=x0))&&(43*5==(x0!!655))!=(x3-593<=951-x3))<=((((x2>x3)==(875>=x0))<(x0&&360)*(590!!x0))>=(((x3>x0)>=880*425)<=((x0<x1)==(x0<222)))))>(((964&&215)-(138!!202)>=((370<x2)<=(x1>=x2)))>=((x0<748)-(242!=x1))-((704-880)-(855&&160))!!(((696<x2)<=x0-35)!=(933+x3!!927&&291))>=((x2>=515)==x0+x0)+((x2>=x3)<=(237<339))))))<x2)<=(x1>=x2)))>=((x0<748)-(242!=x1))-((704-880)-(855&&160))!!(((696<x2)<=x0-35)!=(933+x3!!927&&291))>=((x2>=515)==x0+x0)+((x2>=x3)<=(237<339))))))<x2)<=x0-35)!=(933+x3!!927&&291))>=((x2>=515)==x0+x0)+((x2>=x3)<=(237<339)))))))>((37<x3)!=(x2!=x3)))))!=(((736+x3&&x0==x1!!(x1&&x3)+(193+74))>((x2&&505)>(523==725)&&(317==x2!!412-229)))>=(((x1&&899)>(497==323)&&((522!!x0)!!696-80))==(x0-941!=(529!=498)!!(x3<55)+(207!=x3))))!!(((626>x1)+(469>=787)<=((x2&&529)!=(666!=x0))&&(43*5==(x0!!655))!=(x3-593<=951-x3))<=((((x2>x3)==(875>=x0))<(x0&&360)*(590!!x0))>=(((x3>x0)>=880*425)<=((x0<x1)==(x0<222)))))>(((964&&215)-(138!!202)>=((370<x2)<=(x1>=x2)))>=((x0<748)-(242!=x1))-((704-880)-(855&&160))!!(((696<x2)<=x0-35)!=(933+x3!!927&&291))>=((x2>=515)==x0+x0)+((x2>=x3)<=(237<339)))))
```