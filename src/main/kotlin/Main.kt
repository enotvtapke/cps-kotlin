import cps.Result
import cps.grammar.E
import cps.grammar.lama.Expr
import cps.grammar.lama.Prim
import cps.parser.*
import java.nio.CharBuffer.wrap
import kotlin.io.path.Path
import kotlin.io.path.writeText

fun <T> fix(f: (Parser<T>) -> Parser<T>) = object : Parser<T> {
  private var r: Parser<T>? = null

  override fun invoke(s: CharSequence): Result<Pair<CharSequence, T>> {
    if (r == null) r = f(this)
    return r!!(s)
  }
}

abstract class Par <T> : Parser<T> {
  private var r: Parser<T>? = null
  abstract val par: Parser<T>

  override fun invoke(s: CharSequence): Result<Pair<CharSequence, T>> {
    if (r == null) r = par
    return r!!(s)
  }
}

object CCC: Par<CharSequence>() {
  override val par: Parser<CharSequence>
    get() = memo((CCC bind term("c")) alt term("$"))
}

sealed interface C
data class CCont(val cc: C, val c: String): C
data class CEnd(val a: String): C

fun main() {
  runParser(
    Expr,
    "1+((1*2)-2)"
  )

//  runParser(
//    E,
//    "(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+(1+(1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+((1+1+(1+2)*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2))*2)"
//  )
//
//  runParser(CCC, "\$cccccc")
//

  runParser(
    fix { ccc: Parser<C> ->
      memo(((ccc bind { cc -> term("c").map { CCont(cc, it.toString()) as C } }) alt term("a").map { CEnd("a") }))
    },
    "a" + "c".repeat(3000)
  )

  println(runParser(
    fix { ccc: Parser<(C) -> C> ->
      memo(((ccc bind { cc -> term("c").map { { p: C -> CCont(cc(p), it.toString()) as C } } }) alt term("a").map { { p -> CEnd("a" + (p as CEnd).toString()) } }))
    },
    "a" + "c".repeat(3000)
  )!!(CEnd("p")).toString())
//
//  runParser(
//    fix { pali: Parser<CharSequence> ->
//      memo(
//        (term("a") bind pali bind term("a")) alt
//        (term("b") bind pali bind term("b")) alt
//        (term("c") bind pali bind term("c")) alt
//        term("d")
//      )
//    },
//    "ada" + ("a".repeat(2) + "b".repeat(42) + "c".repeat(80)).repeat(100) + "d" + ("c".repeat(80) + "b".repeat(42) + "a".repeat(2)).repeat(100)
//  )

//  runParser(
//    fix { sss: Parser<CharSequence> ->
//      memo(
//        (term(""))
//      )
//    }
//  )
}

private fun <T> runParser(p: Parser<T>, input: CharSequence): T? {
  var m = 0
  var res1: T? = null
  (p(wrap(input))) { res ->
//    println("Success: $res")
    m += 1
    res1 = res.second
  }
  Path("./out.txt").writeText(res1.toString())
  println("Num of results: $m")
  return res1
}

